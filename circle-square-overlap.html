<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle-Square Overlap (Normalized)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f0f0f0;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 5px;
        }
        .control-group {
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        label {
            min-width: 150px;
            font-weight: 500;
        }
        input[type="range"] {
            flex: 1;
            max-width: 300px;
        }
        .value-display {
            min-width: 80px;
            font-family: monospace;
        }
        .canvas-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .canvas-wrapper {
            flex: 1;
            min-width: 400px;
        }
        canvas {
            border: 2px solid #333;
            display: block;
            background: white;
        }
        .info {
            margin: 10px 0;
            padding: 10px;
            background: #e8f4f8;
            border-radius: 5px;
            font-size: 14px;
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }
        .info-item {
            padding: 5px;
        }
        .info-label {
            font-weight: 600;
            color: #555;
        }
        .info-value {
            color: #2196F3;
            font-family: monospace;
        }
        .case-indicator {
            font-size: 16px;
            font-weight: bold;
            color: #FF5722;
            padding: 10px;
            background: #FFF3E0;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
        }
        h2 {
            margin-top: 0;
            color: #555;
            font-size: 18px;
            border-bottom: 2px solid #2196F3;
            padding-bottom: 5px;
        }
        .note {
            background: #FFF9C4;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 13px;
        }
        .debug {
            background: #E8EAF6;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 11px;
            font-family: monospace;
            max-height: 150px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Circle-Square Overlap Explorer</h1>

        <div class="note">
            <strong>Normalized problem:</strong> Square width = 2 (from -1 to 1), Circle radius R ∈ [0, 1].<br>
            Drag the circle to explore. The app uses the exact formulas from the Haskell implementation.
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="radius">Circle Radius (R):</label>
                <input type="range" id="radius" min="0.1" max="1.0" value="0.5" step="0.01">
                <span class="value-display" id="radiusValue">R = 0.50</span>
            </div>
            <div class="control-group">
                <label for="scale">Display Scale:</label>
                <input type="range" id="scale" min="100" max="300" value="200" step="10">
                <span class="value-display" id="scaleValue">200</span>
            </div>
            <div class="control-group">
                <label for="resolution">3D Resolution:</label>
                <input type="range" id="resolution" min="80" max="240" value="120" step="20">
                <span class="value-display" id="resolutionValue">120</span>
            </div>
            <div class="control-group">
                <label for="showGrid">Show Grid:</label>
                <input type="checkbox" id="showGrid" checked>
            </div>
            <div class="control-group">
                <label for="showRegions">Show Case Regions:</label>
                <input type="checkbox" id="showRegions" checked>
            </div>
            <div class="control-group">
                <label for="showDebug">Show Debug:</label>
                <input type="checkbox" id="showDebug">
            </div>
        </div>

        <div class="case-indicator" id="caseIndicator">Case: -</div>

        <div class="info">
            <div class="info-grid">
                <div class="info-item">
                    <span class="info-label">Center (cx, cy):</span>
                    <span class="info-value" id="circlePos">(0.00, 0.00)</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Overlap Area:</span>
                    <span class="info-value" id="overlapArea">0.000</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Circle Area:</span>
                    <span class="info-value" id="circleArea">0.000</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Overlap %:</span>
                    <span class="info-value" id="overlapPercent">0%</span>
                </div>
            </div>
        </div>

        <div class="debug" id="debugInfo" style="display:none;"></div>

        <div class="canvas-container">
            <div class="canvas-wrapper">
                <h2>Interactive 2D View (Drag circle)</h2>
                <canvas id="canvas2d" width="600" height="600"></canvas>
            </div>
            <div class="canvas-wrapper">
                <h2>3D Surface Plot (Overlap vs position)</h2>
                <canvas id="canvas3d" width="600" height="600"></canvas>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const CANVAS_CENTER = 300;
        const SQUARE_HALF_SIDE = 1.0;  // Normalized: square is [-1, 1] × [-1, 1]

        class CircleSquareOverlap {
            constructor() {
                this.canvas2d = document.getElementById('canvas2d');
                this.ctx = this.canvas2d.getContext('2d');
                this.canvas3d = document.getElementById('canvas3d');

                this.R = 0.5;  // Circle radius in [0, 1]
                this.scale = 200;  // pixels per unit
                this.cx = 0;  // Circle center x in [-?, ?]
                this.cy = 0;  // Circle center y in [-?, ?]

                this.isDragging = false;
                this.resolution = 120;
                this.currentCase = '';
                this.debugText = '';

                this.setupControls();
                this.setup2DCanvas();
                this.setup3DCanvas();
                this.updateDisplay();
            }

            setupControls() {
                document.getElementById('radius').addEventListener('input', (e) => {
                    this.R = parseFloat(e.target.value);
                    document.getElementById('radiusValue').textContent = `R = ${this.R.toFixed(2)}`;
                    this.updateDisplay();
                    this.update3DSurface();
                });

                document.getElementById('scale').addEventListener('input', (e) => {
                    this.scale = parseFloat(e.target.value);
                    document.getElementById('scaleValue').textContent = this.scale;
                    this.updateDisplay();
                });

                document.getElementById('resolution').addEventListener('input', (e) => {
                    this.resolution = parseInt(e.target.value);
                    document.getElementById('resolutionValue').textContent = this.resolution;
                    this.update3DSurface();
                });

                document.getElementById('showGrid').addEventListener('change', () => {
                    this.updateDisplay();
                });

                document.getElementById('showRegions').addEventListener('change', () => {
                    this.updateDisplay();
                });

                document.getElementById('showDebug').addEventListener('change', (e) => {
                    document.getElementById('debugInfo').style.display = e.target.checked ? 'block' : 'none';
                });
            }

            pixelToWorld(px, py) {
                return {
                    x: (px - CANVAS_CENTER) / this.scale,
                    y: (CANVAS_CENTER - py) / this.scale
                };
            }

            worldToPixel(wx, wy) {
                return {
                    x: CANVAS_CENTER + wx * this.scale,
                    y: CANVAS_CENTER - wy * this.scale
                };
            }

            setup2DCanvas() {
                this.canvas2d.addEventListener('mousedown', (e) => {
                    const rect = this.canvas2d.getBoundingClientRect();
                    const px = e.clientX - rect.left;
                    const py = e.clientY - rect.top;
                    const world = this.pixelToWorld(px, py);

                    const dx = world.x - this.cx;
                    const dy = world.y - this.cy;
                    if (dx * dx + dy * dy <= this.R * this.R) {
                        this.isDragging = true;
                    }
                });

                this.canvas2d.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        const rect = this.canvas2d.getBoundingClientRect();
                        const px = e.clientX - rect.left;
                        const py = e.clientY - rect.top;
                        const world = this.pixelToWorld(px, py);
                        this.cx = world.x;
                        this.cy = world.y;
                        this.updateDisplay();
                    }
                });

                this.canvas2d.addEventListener('mouseup', () => {
                    this.isDragging = false;
                });

                this.canvas2d.addEventListener('mouseleave', () => {
                    this.isDragging = false;
                });
            }

            setup3DCanvas() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf0f0f0);

                this.camera = new THREE.PerspectiveCamera(
                    50,
                    this.canvas3d.width / this.canvas3d.height,
                    0.1,
                    20
                );
                this.camera.position.set(3, 3, 3);
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas3d,
                    antialias: true
                });
                this.renderer.setSize(this.canvas3d.width, this.canvas3d.height);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(directionalLight);

                const axesHelper = new THREE.AxesHelper(1.5);
                this.scene.add(axesHelper);

                this.update3DSurface();
                this.animate3D();
            }

            // Haskell formulas - direct translation
            segmentArea(r, sagitta) {
                if (sagitta <= 0 || sagitta > 2 * r) return 0;
                const s = sagitta;
                return r * r * Math.acos(1 - s / r) - (r - s) * Math.sqrt(r * r - (r - s) * (r - s));
            }

            circleArea(r) {
                return Math.PI * r * r;
            }

            // Now: (x, y) are the sagitta values, not coordinates!
            caseBOverlapArea(r, sagitta_y) {
                return this.circleArea(r) - this.segmentArea(r, sagitta_y);
            }

            caseCOverlapArea(r, sagitta_x, sagitta_y) {
                return this.circleArea(r) - this.segmentArea(r, sagitta_x) - this.segmentArea(r, sagitta_y);
            }

            caseDOverlapArea(r, dxToCorner, dyToCorner) {
                // Case D: center inside square, corner inside circle.
                // Use the reference formula (matching the Haskell implementation)
                // where x, y are the distances from the circle center to the
                // square corner along the axes: x = (s - |cx|), y = (s - |cy|).
                const x = dxToCorner;
                const y = dyToCorner;

                if (x < 0 || y < 0) return 0;
                if (x > r || y > r) return 0;

                const sqrtX = Math.sqrt(Math.max(0, r * r - x * x));
                const sqrtY = Math.sqrt(Math.max(0, r * r - y * y));

                const term1 = x * y;
                const term2 = 0.5 * x * sqrtX;
                const term3 = 0.5 * y * sqrtY;

                const chordLen = Math.sqrt((x + sqrtY) * (x + sqrtY) + (y + sqrtX) * (y + sqrtX));
                const ratio = Math.min(1, Math.max(-1, chordLen / (2 * r)));
                const term4 = r * r * Math.asin(ratio);

                return term1 + term2 + term3 + term4;
            }

            caseEOverlapArea(r, sagitta_y) {
                return this.segmentArea(r, sagitta_y);
            }

            caseFOverlapArea(r, x, y) {
                // From Haskell: circleArea r - caseGOverlapArea r (x, -y) - segmentArea r x
                return this.circleArea(r) - this.caseGOverlapArea(r, x, -y) - this.segmentArea(r, x);
            }

            caseGOverlapArea(r, x, y) {
                // Case G: center outside both edges, corner in circle.
                // Compute area as the sector between the two edge intersections
                // minus the two triangles (center, corner, intersection).
                // Fallback to the previous closed-form when inputs do not match
                // the pure "outside both edges" shape (used by Case F mirror).
                const s = SQUARE_HALF_SIDE;

                // Prefer geometric construction when both offsets are positive.
                if (x > 0 && y > 0) {
                    if (x >= r || y >= r || x * x + y * y > r * r) return 0;

                    const vertDelta = r * r - x * x;
                    const horizDelta = r * r - y * y;
                    if (vertDelta <= 0 || horizDelta <= 0) return 0;

                    const vertOffset = Math.sqrt(vertDelta);   // distance along y to x=s
                    const horizOffset = Math.sqrt(horizDelta); // distance along x to y=s

                    const cx = s + x;
                    const cy = s + y;

                    const pickOnEdge = (candidates) => {
                        const inSquare = candidates.filter((v) => Math.abs(v) <= s + 1e-9);
                        if (inSquare.length === 0) return null;
                        const closest = inSquare.reduce((best, val) => {
                            const dist = Math.abs(val - s);
                            const bestDist = Math.abs(best - s);
                            return dist < bestDist ? val : best;
                        }, inSquare[0]);
                        return closest;
                    };

                    const yOnVertical = pickOnEdge([cy - vertOffset, cy + vertOffset]);
                    const xOnHorizontal = pickOnEdge([cx - horizOffset, cx + horizOffset]);
                    if (yOnVertical === null || xOnHorizontal === null) return 0;

                    const cornerVec = { x: -x, y: -y };
                    const vertVec = { x: s - cx, y: yOnVertical - cy };    // toward x = s
                    const horizVec = { x: xOnHorizontal - cx, y: s - cy }; // toward y = s

                    const angleDelta = (from, to) => {
                        let diff = to - from;
                        if (diff < 0) diff += 2 * Math.PI;
                        return diff;
                    };

                    const normalize = (a) => {
                        let ang = a % (2 * Math.PI);
                        if (ang < 0) ang += 2 * Math.PI;
                        return ang;
                    };

                    const angleH = normalize(Math.atan2(horizVec.y, horizVec.x));
                    const angleV = normalize(Math.atan2(vertVec.y, vertVec.x));
                    const angleCorner = normalize(Math.atan2(cornerVec.y, cornerVec.x));

                    const isBetweenCCW = (start, end, test) =>
                        angleDelta(start, test) <= angleDelta(start, end) + 1e-12;

                    const ccwArc = angleDelta(angleH, angleV);
                    const cwArc = 2 * Math.PI - ccwArc;
                    const sectorTheta = isBetweenCCW(angleH, angleV, angleCorner) ? ccwArc : cwArc;

                    const sectorArea = 0.5 * r * r * sectorTheta;

                    const cross = (a, b) => a.x * b.y - a.y * b.x;
                    const triangle1 = 0.5 * Math.abs(cross(cornerVec, horizVec));
                    const triangle2 = 0.5 * Math.abs(cross(cornerVec, vertVec));

                    return Math.max(0, sectorArea - triangle1 - triangle2);
                }

                // Fallback (supports mixed-edge case reuse by Case F)
                if (x >= r || Math.abs(y) >= r || x * x + y * y > r * r) return 0;

                const term1 = x * y;
                const term2 = 0.5 * x * Math.sqrt(r * r - x * x);
                const term3 = 0.5 * x * Math.sqrt(r * r - y * y);

                const sqrtTerm1 = Math.sqrt(r * r - y * y);
                const sqrtTerm2 = Math.sqrt(r * r - x * x);
                const numerator = (x + sqrtTerm1) ** 2 + (y + sqrtTerm2) ** 2;
                const term4 = r * r * Math.asin(Math.min(1, Math.sqrt(numerator) / (2 * r)));

                return term1 + term2 + term3 + term4;
            }

            calculateOverlap(cx, cy, R) {
                this.debugText = `cx=${cx.toFixed(3)}, cy=${cy.toFixed(3)}, R=${R.toFixed(3)}\n`;

                // Work with absolute values (symmetry)
                const ax = Math.abs(cx);
                const ay = Math.abs(cy);

                // Square is [-1, 1] × [-1, 1]
                const s = SQUARE_HALF_SIDE;

                // Distance from center beyond square edges
                const dx = Math.max(0, ax - s);
                const dy = Math.max(0, ay - s);

                // Distance to nearest corner (positive quadrant corner is at (s, s) = (1, 1))
                const distToNearestCorner = Math.sqrt((ax - s) * (ax - s) + (ay - s) * (ay - s));
                const cornerInCircle = distToNearestCorner <= R;

                this.debugText += `|cx|=${ax.toFixed(3)}, |cy|=${ay.toFixed(3)}\n`;
                this.debugText += `dx=${dx.toFixed(3)}, dy=${dy.toFixed(3)}\n`;
                this.debugText += `distToCorner=${distToNearestCorner.toFixed(3)}, cornerInCircle=${cornerInCircle}\n`;

                // Sagittas (how far circle extends beyond edges)
                const sagitta_x = Math.max(0, ax + R - s);
                const sagitta_y = Math.max(0, ay + R - s);

                this.debugText += `sagitta_x=${sagitta_x.toFixed(3)}, sagitta_y=${sagitta_y.toFixed(3)}\n`;

                // Circle fully inside
                if (ax + R <= s && ay + R <= s) {
                    this.currentCase = 'A';
                    this.debugText += 'Case A: Fully inside\n';
                    return this.circleArea(R);
                }

                // Check for no overlap - circle doesn't reach square
                if (dx > 0 && dy > 0 && distToNearestCorner > R) {
                    this.currentCase = 'H';
                    this.debugText += 'Case H: No overlap\n';
                    return 0;
                }

                // Determine if we're in a corner-influenced case
                const inCornerRegion = sagitta_x > 0 && sagitta_y > 0;

                if (inCornerRegion) {
                    // Circle extends beyond both edges
                    if (ax < s && ay < s) {
                        // Center inside square, circle extends to corner region
                        if (cornerInCircle) {
                            this.currentCase = 'D';
                            this.debugText += 'Case D: Center inside, corner inside circle\n';
                            const dxCorner = s - ax;
                            const dyCorner = s - ay;
                            return this.caseDOverlapArea(R, dxCorner, dyCorner);
                        } else {
                            this.currentCase = 'C';
                            this.debugText += 'Case C: Center inside, corner outside circle\n';
                            return this.caseCOverlapArea(R, sagitta_x, sagitta_y);
                        }
                    } else if (ax >= s && ay >= s) {
                        // Center outside both edges
                        if (cornerInCircle) {
                            this.currentCase = 'G';
                            this.debugText += 'Case G: Corner sector (center outside both)\n';
                            return this.caseGOverlapArea(R, dx, dy);
                        }
                        // else fall through to check E/H below
                    } else {
                        // Center outside one edge, inside the other
                        if (cornerInCircle) {
                            this.currentCase = 'F';
                            this.debugText += 'Case F: Mixed position, corner inside circle\n';
                            return this.caseFOverlapArea(R, dx, dy);
                        }
                        // else fall through to check E/H below
                    }
                }

                // Case B: Center inside, extends beyond one or more edges
                if (ax < s && ay < s && (sagitta_x > 0 || sagitta_y > 0)) {
                    this.currentCase = 'B';
                    this.debugText += 'Case B: Center inside, extends beyond edge(s)\n';
                    const sag = Math.max(sagitta_x, sagitta_y);
                    return this.caseBOverlapArea(R, sag);
                }

                // Case E: Center outside, circle reaches square edge
                // For center outside square: check if we can reach an edge
                if ((ax >= s || ay >= s)) {
                    // Distance to closest edge (considering we might be inside in one dimension)
                    const dxToEdge = ax >= s ? (ax - s) : 0;
                    const dyToEdge = ay >= s ? (ay - s) : 0;

                    // Check if circle reaches square
                    if ((ax >= s && dxToEdge <= R) || (ay >= s && dyToEdge <= R)) {
                        this.currentCase = 'E';
                        this.debugText += 'Case E: Edge segment (center outside)\n';
                        // For Case E: sagitta = R - distance_to_edge
                        const sagE_x = ax >= s ? (R - dxToEdge) : 0;
                        const sagE_y = ay >= s ? (R - dyToEdge) : 0;
                        const sagE = Math.max(sagE_x, sagE_y);
                        this.debugText += `sagE_x=${sagE_x.toFixed(3)}, sagE_y=${sagE_y.toFixed(3)}, sagE=${sagE.toFixed(3)}\n`;
                        return this.caseEOverlapArea(R, sagE);
                    }
                }

                // Case H: No overlap
                this.currentCase = 'H';
                this.debugText += 'Case H: No overlap\n';
                return 0;

                return 0;
            }

            update3DSurface() {
                if (this.surfaceMesh) {
                    this.scene.remove(this.surfaceMesh);
                }
                if (this.wireframe) {
                    this.scene.remove(this.wireframe);
                }

                const res = this.resolution;
                const range = 4;  // Show region from -2 to 2
                const geometry = new THREE.PlaneGeometry(range, range, res - 1, res - 1);
                const vertices = geometry.attributes.position.array;

                // Remap geometry: X (red) and Z (blue) are inputs, Y (green) is height
                for (let i = 0; i < res; i++) {
                    for (let j = 0; j < res; j++) {
                        const idx = (i * res + j) * 3;
                        const x = vertices[idx];        // Red axis - input
                        const z = vertices[idx + 1];    // Blue axis - input (read before overwrite)

                        const overlap = this.calculateOverlap(x, -z, this.R);

                        // Normalize height to π (max possible overlap) so it stays in view
                        vertices[idx + 1] = overlap / Math.PI;  // Green - height (normalized)
                        vertices[idx + 2] = z;                   // Blue - input
                    }
                }

                geometry.attributes.position.needsUpdate = true;
                geometry.computeVertexNormals();

                const material = new THREE.MeshPhongMaterial({
                    color: 0x2196F3,
                    side: THREE.DoubleSide,
                    shininess: 80,
                    opacity: 0.85,
                    transparent: true
                });

                this.surfaceMesh = new THREE.Mesh(geometry, material);
                this.scene.add(this.surfaceMesh);

                const wireframeGeometry = new THREE.WireframeGeometry(geometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({
                    color: 0x000000,
                    opacity: 0.15,
                    transparent: true
                });
                this.wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
                this.scene.add(this.wireframe);
            }

            animate3D() {
                requestAnimationFrame(() => this.animate3D());

                if (this.surfaceMesh) {
                    this.surfaceMesh.rotation.y += 0.002;
                    this.wireframe.rotation.y += 0.002;
                }

                this.renderer.render(this.scene, this.camera);
            }

            updateDisplay() {
                this.draw2D();
                this.updateInfo();
            }

            draw2D() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, 600, 600);

                const showGrid = document.getElementById('showGrid').checked;

                // Grid
                if (showGrid) {
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 1;
                    for (let i = -2; i <= 2; i += 0.5) {
                        const px = this.worldToPixel(i, 0).x;
                        const py = this.worldToPixel(0, i).y;
                        ctx.beginPath();
                        ctx.moveTo(px, 0);
                        ctx.lineTo(px, 600);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(0, py);
                        ctx.lineTo(600, py);
                        ctx.stroke();
                    }
                }

                // Axes
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                const origin = this.worldToPixel(0, 0);
                ctx.beginPath();
                ctx.moveTo(origin.x, 0);
                ctx.lineTo(origin.x, 600);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, origin.y);
                ctx.lineTo(600, origin.y);
                ctx.stroke();

                // Draw case regions if enabled (before square so square is on top)
                if (document.getElementById('showRegions').checked) {
                    this.drawCaseRegions();
                }

                // Square
                const topLeft = this.worldToPixel(-1, 1);
                const bottomRight = this.worldToPixel(1, -1);
                const width = bottomRight.x - topLeft.x;
                const height = bottomRight.y - topLeft.y;

                ctx.fillStyle = 'rgba(76, 175, 80, 0.2)';
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 3;
                ctx.fillRect(topLeft.x, topLeft.y, width, height);
                ctx.strokeRect(topLeft.x, topLeft.y, width, height);

                // Circle
                const circleCenter = this.worldToPixel(this.cx, this.cy);
                const circleRadius = this.R * this.scale;

                ctx.fillStyle = 'rgba(33, 150, 243, 0.2)';
                ctx.strokeStyle = '#2196F3';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(circleCenter.x, circleCenter.y, circleRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();

                // Draw overlap region
                this.drawOverlapRegion();

                // Labels
                ctx.fillStyle = '#000';
                ctx.font = 'bold 14px monospace';
                ctx.fillText(`R = ${this.R.toFixed(2)}`, 10, 25);
                ctx.fillText(`Center: (${this.cx.toFixed(2)}, ${this.cy.toFixed(2)})`, 10, 45);
            }

            drawCaseRegions() {
                const ctx = this.ctx;
                const R = this.R;
                const s = 1;  // square half-side

                // Define colors for each case
                const caseColors = {
                    'A': 'rgba(0, 255, 255, 0.15)',      // cyan
                    'B': 'rgba(0, 0, 255, 0.15)',        // blue
                    'C': 'rgba(255, 0, 255, 0.15)',      // magenta
                    'D': 'rgba(255, 255, 0, 0.15)',      // yellow
                    'E': 'rgba(255, 0, 0, 0.15)',        // red
                    'F': 'rgba(0, 128, 0, 0.15)',        // green
                    'G': 'rgba(255, 128, 0, 0.15)',      // orange
                    'H': 'rgba(200, 200, 200, 0.15)'     // gray
                };

                // Sample the entire visible space uniformly
                const samples = 150;
                const maxRange = 2;  // Show up to distance 2 from origin in each direction

                for (let i = 0; i < samples; i++) {
                    for (let j = 0; j < samples; j++) {
                        // Map to world coordinates from -maxRange to +maxRange
                        const wx = -maxRange + (i / samples) * (2 * maxRange);
                        const wy = -maxRange + (j / samples) * (2 * maxRange);

                        // Determine case for this position (matching calculateOverlap logic)
                        const ax = Math.abs(wx);
                        const ay = Math.abs(wy);
                        const dx = Math.max(0, ax - s);
                        const dy = Math.max(0, ay - s);

                        const distToNearestCorner = Math.sqrt((ax - s) * (ax - s) + (ay - s) * (ay - s));
                        const cornerInCircle = distToNearestCorner <= R;

                        const sagitta_x = Math.max(0, ax + R - s);
                        const sagitta_y = Math.max(0, ay + R - s);

                        let caseType = '';

                        // Circle fully inside
                        if (ax + R <= s && ay + R <= s) {
                            caseType = 'A';
                        } else if (dx > 0 && dy > 0 && distToNearestCorner > R) {
                            // No overlap (too far from corner)
                            caseType = 'H';
                        } else {
                            const inCornerRegion = sagitta_x > 0 && sagitta_y > 0;

                            // Check corner-influenced cases first
                            if (inCornerRegion) {
                                if (ax < s && ay < s) {
                                    caseType = cornerInCircle ? 'D' : 'C';
                                } else if (ax >= s && ay >= s) {
                                    if (cornerInCircle) {
                                        caseType = 'G';
                                    }
                                    // else fall through to E/H check
                                } else {
                                    if (cornerInCircle) {
                                        caseType = 'F';
                                    }
                                    // else fall through to E/H check
                                }
                            }

                            // Case B: center inside, extends beyond edge(s)
                            if (!caseType && ax < s && ay < s && (sagitta_x > 0 || sagitta_y > 0)) {
                                caseType = 'B';
                            }

                            // Case E: center outside, circle reaches edge
                            if (!caseType && (ax >= s || ay >= s)) {
                                const dxToEdge = ax >= s ? (ax - s) : 0;
                                const dyToEdge = ay >= s ? (ay - s) : 0;
                                if ((ax >= s && dxToEdge <= R) || (ay >= s && dyToEdge <= R)) {
                                    caseType = 'E';
                                }
                            }

                            // Case H: no overlap
                            if (!caseType) {
                                caseType = 'H';
                            }
                        }

                        if (caseType && caseColors[caseType]) {
                            ctx.fillStyle = caseColors[caseType];
                            const cellSize = (2 * maxRange) / samples;

                            // Draw this single cell
                            const p1 = this.worldToPixel(wx, wy);
                            const p2 = this.worldToPixel(wx + cellSize, wy + cellSize);
                            const w = Math.abs(p2.x - p1.x);
                            const h = Math.abs(p2.y - p1.y);
                            ctx.fillRect(p1.x, p1.y, w, h);
                        }
                    }
                }

                // Draw labels for each region
                ctx.font = 'bold 16px monospace';
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;

                const baseLabels = [
                    { case: 'A', pos: [0, 0], color: '#00CCCC', unique: true },
                    { case: 'B', pos: [0, s - R * 0.5], color: '#0000CC' },
                    { case: 'C', pos: [s - R * 0.8, s - R * 0.8], color: '#CC00CC' },
                    { case: 'D', pos: [s - R * 0.4, s - R * 0.4], color: '#CCCC00' },
                    { case: 'E', pos: [s + R * 0.5, 0], color: '#CC0000' },
                    { case: 'F', pos: [s - R * 0.4, s + R * 0.4], color: '#008800' },
                    { case: 'G', pos: [s + R * 0.4, s + R * 0.4], color: '#CC8800' },
                    { case: 'H', pos: [s + R * 0.85, s + R * 0.85], color: '#888888' }
                ];

                // Generate labels with 8-fold symmetry (except A which is unique)
                const labels = [];
                for (const label of baseLabels) {
                    if (label.unique) {
                        labels.push(label);
                    } else {
                        const [x, y] = label.pos;
                        // Add all symmetric positions
                        labels.push({ case: label.case, pos: [x, y], color: label.color });
                        labels.push({ case: label.case, pos: [-x, y], color: label.color });
                        labels.push({ case: label.case, pos: [x, -y], color: label.color });
                        labels.push({ case: label.case, pos: [-x, -y], color: label.color });
                        // Also swap x and y for 8-fold symmetry
                        if (x !== y) {
                            labels.push({ case: label.case, pos: [y, x], color: label.color });
                            labels.push({ case: label.case, pos: [-y, x], color: label.color });
                            labels.push({ case: label.case, pos: [y, -x], color: label.color });
                            labels.push({ case: label.case, pos: [-y, -x], color: label.color });
                        }
                    }
                }

                for (const label of labels) {
                    const pixel = this.worldToPixel(label.pos[0], label.pos[1]);
                    const text = label.case;

                    // Draw text with white outline
                    ctx.strokeText(text, pixel.x - 8, pixel.y + 6);
                    ctx.fillStyle = label.color;
                    ctx.fillText(text, pixel.x - 8, pixel.y + 6);
                }
            }

            drawOverlapRegion() {
                const ctx = this.ctx;
                const squareTopLeft = this.worldToPixel(-1, 1);
                const squareBottomRight = this.worldToPixel(1, -1);
                const squareWidth = squareBottomRight.x - squareTopLeft.x;
                const squareHeight = squareBottomRight.y - squareTopLeft.y;

                const circleCenter = this.worldToPixel(this.cx, this.cy);
                const circleRadius = this.R * this.scale;

                ctx.save();
                // Clip to the square, then draw the circle so only the overlap remains.
                ctx.beginPath();
                ctx.rect(squareTopLeft.x, squareTopLeft.y, squareWidth, squareHeight);
                ctx.clip();

                ctx.fillStyle = 'rgba(255, 152, 0, 0.4)';
                ctx.strokeStyle = '#FF9800';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(circleCenter.x, circleCenter.y, circleRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }

            updateInfo() {
                document.getElementById('circlePos').textContent =
                    `(${this.cx.toFixed(2)}, ${this.cy.toFixed(2)})`;

                const overlap = this.calculateOverlap(this.cx, this.cy, this.R);
                document.getElementById('overlapArea').textContent = overlap.toFixed(4);

                const circleArea = Math.PI * this.R * this.R;
                document.getElementById('circleArea').textContent = circleArea.toFixed(4);

                const percent = (overlap / circleArea * 100).toFixed(1);
                document.getElementById('overlapPercent').textContent = `${percent}%`;

                const caseNames = {
                    'A': 'Case A: πR² (Circle fully inside)',
                    'B': 'Case B: πR² - segment (Extends beyond one edge)',
                    'C': 'Case C: πR² - 2 segments (Extends beyond two edges)',
                    'D': 'Case D: Complex (Asymmetric corner case)',
                    'E': 'Case E: Single segment (Mostly outside, edge)',
                    'F': 'Case F: (Alternative configuration)',
                    'G': 'Case G: Corner sector (Mostly outside, corner)',
                    'H': 'Case H: 0 (No overlap)'
                };
                document.getElementById('caseIndicator').textContent =
                    caseNames[this.currentCase] || 'Case: Unknown';

                document.getElementById('debugInfo').textContent = this.debugText;
            }
        }

        window.addEventListener('load', () => {
            new CircleSquareOverlap();
        });
    </script>
</body>
</html>
